import os
import asyncio
import tempfile
import time
import random
import json
import re
import requests
import io
from typing import Tuple, List, Optional, Dict, Any
import logging

try:
    import yt_dlp
except ImportError:
    yt_dlp = None

logger = logging.getLogger(__name__)

# ุงูุฏููู ุงูุฐู ูุญุชูู ุนูู ุงูุฃุบุงูู ุงููุฎุฒูุฉ ูุณุจููุง
ASSETS_DIR = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "assets")
MUSIC_DIR = os.path.join(ASSETS_DIR, "music")

# ุชุฃูุฏ ูู ูุฌูุฏ ูุฌูุฏ ุงูุฃุบุงูู
os.makedirs(MUSIC_DIR, exist_ok=True)

# Cache for storing already downloaded songs
song_cache = {}

# ูุตุงุฏุฑ ูุฎุชููุฉ ููููุณููู ูุงููุญุชูู ุงูุตูุชู
# ูู ูุตุฏุฑ ูู ูุฌููุนุฉ ูู ุงูุนูุงุตุฑ ุงููุชุงุญุฉ

# ุฃุบุงูู ูุถููุฉ ูุณุจููุง ูู ุงูุจูุช
EMBEDDED_SONGS = [
    {
        "title": "ุฃุบููุฉ ุญูุงุณูุฉ - ููุณููู ุชุตููุฑูุฉ",
        "id": "song1",
        "filename": "embedded_song1.mp3",
        "performer": "ุงูุจูุช ุงูููุณููู",
        "source": "ููุชุจุฉ ุงูุจูุช"
    },
    {
        "title": "ููุณููู ูุงุฏุฆุฉ ููุงุณุชุฑุฎุงุก",
        "id": "song2",
        "filename": "embedded_song2.mp3",
        "performer": "ุงูุจูุช ุงูููุณููู",
        "source": "ููุชุจุฉ ุงูุจูุช"
    },
    {
        "title": "ุฃูุบุงู ููุงุณูููุฉ - ููุชุณุงุฑุช",
        "id": "song3",
        "filename": "embedded_song3.mp3",
        "performer": "ุงูุจูุช ุงูููุณููู",
        "source": "ููุชุจุฉ ุงูุจูุช"
    }
]

# ููุณููู ุนุฑุจูุฉ ุดููุฑุฉ ููุจุญุซ
ARABIC_SONGS = [
    {"title": "ุนูุฑู ุฏูุงุจ - ููู ุชูุงุช", "id": "arabic1", "source": "ููุชุจุฉ ุงูุฃุบุงูู ุงูุนุฑุจูุฉ"},
    {"title": "ุชุงูุฑ ุญุณูู - ูุงุณููู ููู", "id": "arabic2", "source": "ููุชุจุฉ ุงูุฃุบุงูู ุงูุนุฑุจูุฉ"},
    {"title": "ุฅููุณุง - ุนุจุงูู ุญุจูุจู", "id": "arabic3", "source": "ููุชุจุฉ ุงูุฃุบุงูู ุงูุนุฑุจูุฉ"},
    {"title": "ูุญูุฏ ุญูุงูู - ูุง ุจูุงุด", "id": "arabic4", "source": "ููุชุจุฉ ุงูุฃุบุงูู ุงูุนุฑุจูุฉ"},
    {"title": "ุฃุตุงูุฉ - ุดุงูุฎ", "id": "arabic5", "source": "ููุชุจุฉ ุงูุฃุบุงูู ุงูุนุฑุจูุฉ"}
]

# ููุณููู ุนุงูููุฉ ุดุงุฆุนุฉ
GLOBAL_SONGS = [
    {"title": "Imagine Dragons - Believer", "id": "global1", "source": "ููุชุจุฉ ุงูุฃุบุงูู ุงูุนุงูููุฉ"},
    {"title": "The Weeknd - Blinding Lights", "id": "global2", "source": "ููุชุจุฉ ุงูุฃุบุงูู ุงูุนุงูููุฉ"},
    {"title": "Billie Eilish - bad guy", "id": "global3", "source": "ููุชุจุฉ ุงูุฃุบุงูู ุงูุนุงูููุฉ"},
    {"title": "Sia - Cheap Thrills", "id": "global4", "source": "ููุชุจุฉ ุงูุฃุบุงูู ุงูุนุงูููุฉ"},
    {"title": "Ed Sheeran - Shape of You", "id": "global5", "source": "ููุชุจุฉ ุงูุฃุบุงูู ุงูุนุงูููุฉ"}
]

# ูุฑุขู ูุฑูู (ุณูุฑ ูุฑุขููุฉ)
QURAN_RECITATIONS = [
    {"title": "ุณูุฑุฉ ุงููุงุชุญุฉ - ุงูุดูุฎ ุนุจุฏ ุงูุจุงุณุท", "id": "quran1", "source": "ุงููุตุญู ุงููุฑุชู"},
    {"title": "ุณูุฑุฉ ุงูุฑุญูู - ุงูุดูุฎ ุงูููุดุงูู", "id": "quran2", "source": "ุงููุตุญู ุงููุฑุชู"},
    {"title": "ุณูุฑุฉ ูุณ - ุงูุดูุฎ ูุญููุฏ ุฎููู ุงูุญุตุฑู", "id": "quran3", "source": "ุงููุตุญู ุงููุฑุชู"},
    {"title": "ุณูุฑุฉ ุงูููู - ุงูุดูุฎ ูุญูุฏ ุตุฏูู ุงูููุดุงูู", "id": "quran4", "source": "ุงููุตุญู ุงููุฑุชู"},
    {"title": "ุณูุฑุฉ ุงูููู - ุงูุดูุฎ ูุดุงุฑู ุงูุนูุงุณู", "id": "quran5", "source": "ุงููุตุญู ุงููุฑุชู"}
]

# ูุคุซุฑุงุช ุตูุชูุฉ
SOUND_EFFECTS = [
    {"title": "ุตูุช ุงููุทุฑ", "id": "effect1", "source": "ูุคุซุฑุงุช ุตูุชูุฉ"},
    {"title": "ุฃููุงุฌ ุงูุจุญุฑ", "id": "effect2", "source": "ูุคุซุฑุงุช ุตูุชูุฉ"},
    {"title": "ุฃุตูุงุช ุงูุบุงุจุฉ", "id": "effect3", "source": "ูุคุซุฑุงุช ุตูุชูุฉ"},
    {"title": "ุตูุช ุงูุฑุนุฏ", "id": "effect4", "source": "ูุคุซุฑุงุช ุตูุชูุฉ"},
    {"title": "ููุณููู ุชุฃูู", "id": "effect5", "source": "ูุคุซุฑุงุช ุตูุชูุฉ"}
]

# ุฏูุฌ ุฌููุน ูุตุงุฏุฑ ุงูููุณููู ูู ูุงููุณ ูุงุญุฏ ูููุตูู ุงูุณูู
ALL_MUSIC_SOURCES = {
    "embedded": EMBEDDED_SONGS,
    "arabic": ARABIC_SONGS,
    "global": GLOBAL_SONGS,
    "quran": QURAN_RECITATIONS,
    "effects": SOUND_EFFECTS
}

# ุงูุญุตูู ุนูู ุฌููุน ุงูุฃุบุงูู ูู ุฌููุน ุงููุตุงุฏุฑ ูู ูุงุฆูุฉ ูุงุญุฏุฉ
ALL_SONGS = EMBEDDED_SONGS + ARABIC_SONGS + GLOBAL_SONGS + QURAN_RECITATIONS + SOUND_EFFECTS

# List of alternative user agents to rotate
USER_AGENTS = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:90.0) Gecko/20100101 Firefox/90.0',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 11.5; rv:90.0) Gecko/20100101 Firefox/90.0',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 Edg/91.0.864.59',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 11_5_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Safari/605.1.15'
]

# ุฃุฏุงุฉ ูุณุงุนุฏุฉ ููุญุตูู ุนูู ูุนูููุงุช ุฃุณุงุณูุฉ ุนู ููุฏูู ุนูู ููุชููุจ ุจุฏูู ุงุณุชุฎุฏุงู yt-dlp
async def get_youtube_info_simple(video_id: str) -> Optional[Dict[str, Any]]:
    """
    ุงูุญุตูู ุนูู ูุนูููุงุช ุฃุณุงุณูุฉ ุนู ููุฏูู ุนูู ููุชููุจ ุจุงุณุชุฎุฏุงู ูุงุฌูุฉ ุจุฑูุฌุฉ ุจุณูุทุฉ.
    
    Args:
        video_id: ูุนุฑู ุงูููุฏูู
        
    Returns:
        ูุนูููุงุช ุงูููุฏูู ุฃู None ูู ุญุงูุฉ ุงููุดู
    """
    try:
        url = f"https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v={video_id}&format=json"
        user_agent = random.choice(USER_AGENTS)
        headers = {
            'User-Agent': user_agent,
            'Accept-Language': 'en-US,en;q=0.5',
            'Referer': 'https://www.youtube.com/results',
        }
        
        response = requests.get(url, headers=headers)
        if response.status_code == 200:
            data = response.json()
            return {
                'title': data.get('title', 'Unknown'),
                'uploader': data.get('author_name', 'Unknown'),
                'thumbnail': data.get('thumbnail_url', None),
                'video_id': video_id,
                'webpage_url': f"https://www.youtube.com/watch?v={video_id}"
            }
    except Exception as e:
        logger.warning(f"ูุดู ูู ุงูุญุตูู ุนูู ูุนูููุงุช ุงูููุฏูู ุงูุจุณูุทุฉ: {e}")
    
    return None

async def search_youtube(query: str) -> List[Tuple[str, str]]:
    """
    ุงูุจุญุซ ุนู ูููุงุช ุตูุชูุฉ ูู ููุชููุจ ูุจุงุดุฑุฉ.
    
    Args:
        query: ูููุงุช ุงูุจุญุซ.
        
    Returns:
        ูุงุฆูุฉ ุจุงููุชุงุฆุฌ ูุฃุฒูุงุฌ (ุงูุนููุงูุ ุงููุนุฑู).
    """
    try:
        if not yt_dlp:
            raise ImportError("yt-dlp is not installed")

        ydl_opts = {
            'quiet': True,
            'no_warnings': True,
            'extract_flat': True,
            'default_search': 'ytsearch5',  # ุงูุจุญุซ ุนู 5 ูุชุงุฆุฌ
        }

        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            # ุงูุจุญุซ ูู ููุชููุจ
            results = await asyncio.get_event_loop().run_in_executor(
                None, 
                lambda: ydl.extract_info(f"ytsearch5:{query}", download=False)
            )
            
            if not results or 'entries' not in results:
                raise Exception("No results found")

            # ุชุญููู ุงููุชุงุฆุฌ ุฅูู ุงูุชูุณูู ุงููุทููุจ
            formatted_results = []
            for entry in results['entries']:
                if entry:
                    title = entry.get('title', 'Unknown Title')
                    video_id = entry.get('id', '')
                    formatted_results.append((f"๐ต {title}", video_id))

            return formatted_results[:5]  # ุฅุฑุฌุงุน ุฃูู 5 ูุชุงุฆุฌ

    except Exception as e:
        logger.error(f"ุฎุทุฃ ูู ุงูุจุญุซ: {e}")
        # ูู ุญุงูุฉ ุญุฏูุซ ุฎุทุฃุ ูุฑุฌุน ูุงุฆูุฉ ูุงุฑุบุฉ
        return []

def get_prefix_for_category(category: str) -> str:
    """
    ุงูุญุตูู ุนูู ุฑูุฒ ุชุนุจูุฑู ููุงุณุจ ููุฆุฉ ุงูููุณููู.
    
    Args:
        category: ุงุณู ุงููุฆุฉ.
        
    Returns:
        ุฑูุฒ ุชุนุจูุฑู ููุงุณุจ.
    """
    prefixes = {
        "embedded": "๐ต",
        "arabic": "๐ผ",
        "global": "๐ธ",
        "quran": "๐",
        "effects": "๐ง"
    }
    return prefixes.get(category, "๐ต")

async def play_music(url: str, chat_id: int) -> Tuple[bool, Any]:
    """
    ุชุดุบูู ููู ุตูุชู ุจุงุณุชุฎุฏุงู ูุนุฑู ุงูุฃุบููุฉ.
    
    Args:
        url: ูุนุฑู ุงูุฃุบููุฉ ุฃู ุฑุงุจุท ููุชููุจ.
        chat_id: ูุนุฑู ุงููุญุงุฏุซุฉ ูุชุชุจุน ุงูุฃุบุงูู ูู ุงููุญุงุฏุซุงุช ุงููุฎุชููุฉ.
        
    Returns:
        ุฒูุฌ ูู (ูุฌุงุญ ุงูุนูููุฉุ ุงููุชูุฌุฉ) ุญูุซ ุชููู ุงููุชูุฌุฉ ุฅูุง ููู ุตูุชู ุฃู ุฑุณุงูุฉ ุฎุทุฃ.
    """
    # ุงุณุชุฎุฑุงุฌ ูุนุฑู ุงูููุฏูู ูู ุงูุฑุงุจุท
    video_id = url
    if url.startswith(('http://', 'https://')):
        # ุงุณุชุฎุฑุงุฌ ูุนุฑู ุงูููุฏูู ูู ุงูุฑุงุจุท
        if 'youtube.com' in url or 'youtu.be' in url:
            if 'v=' in url:
                video_id = url.split('v=')[1].split('&')[0]
            elif 'youtu.be/' in url:
                video_id = url.split('youtu.be/')[1].split('?')[0]
    else:
        # ุฅุฐุง ูุงู ูุนุฑู ููุฏูู ููุท
        if len(url) >= 11:  # ุทูู ูุนุฑู ููุฏูู ุงูููุชููุจ ุงููููุฐุฌู ูู 11 ุญุฑููุง
            video_id = url
            url = f"https://www.youtube.com/watch?v={video_id}"
    
    try:
        # ุงูุชุญูู ููุง ุฅุฐุง ูุงูุช ุงูุฃุบููุฉ ูุฎุฒูุฉ ูุณุจููุง ูู ุงูุฐุงูุฑุฉ ุงููุคูุชุฉ
        if url in song_cache:
            return True, song_cache[url]
        
        # ุงูุจุญุซ ูู ุฌููุน ุงููุตุงุฏุฑ ุงููุชุงุญุฉ
        for category, songs_list in ALL_MUSIC_SOURCES.items():
            for song in songs_list:
                if video_id == song["id"]:
                    logger.info(f"ุชุดุบูู ููู ุตูุชู ูู {song.get('source', category)}: {song['title']}")
                    return await serve_embedded_song(song)
        
        # ูู ุญุงูุฉ ูุงู ุงูุงุณุชุนูุงู ุนู ููุฏูู ููุชููุจ (ูุนุฑู ููุฏูู ูู 11 ุญุฑููุง)ุ ููุฏู ุจุฏูููุง ููุงุณุจูุง
        if len(video_id) == 11:  # ูุนุฑู ููุฏูู ููุชููุจ ุนุงุฏุฉู ูุง ูููู 11 ุญุฑููุง
            # ุงุฎุชูุงุฑ ุฃุบููุฉ ุนุดูุงุฆูุฉ ูู ุงูุฃุบุงูู ุงูุนุงูููุฉ ุฃู ุงูุนุฑุจูุฉ
            available_sources = []
            if 'global' in ALL_MUSIC_SOURCES and ALL_MUSIC_SOURCES['global']:
                available_sources.append(ALL_MUSIC_SOURCES['global'])
            if 'arabic' in ALL_MUSIC_SOURCES and ALL_MUSIC_SOURCES['arabic']:
                available_sources.append(ALL_MUSIC_SOURCES['arabic'])
                
            if available_sources:
                # ุงุฎุชูุงุฑ ูุตุฏุฑ ุนุดูุงุฆู ุซู ุฃุบููุฉ ุนุดูุงุฆูุฉ
                source = random.choice(available_sources)
                selected_song = random.choice(source)
                logger.info(f"ุชูุฏูู ุฃุบููุฉ ุจุฏููุฉ ูู {selected_song.get('source', 'ุงูููุชุจุฉ')}: {selected_song['title']}")
                return await serve_embedded_song(selected_song)
        
        # ูู ุญุงูุฉ ูู ูุชู ุงูุนุซูุฑ ุนูู ุงูุฃุบููุฉุ ูู ุจุฅุฑุฌุงุน ุฃุบููุฉ ุนุดูุงุฆูุฉ ูู ุงูุฃุบุงูู ุงููุถููุฉ
        random_song = EMBEDDED_SONGS[random.randint(0, len(EMBEDDED_SONGS)-1)]
        logger.info(f"ุชูุฏูู ุฃุบููุฉ ุจุฏููุฉ: {random_song['title']}")
        
        return await serve_embedded_song(random_song)
        
    except Exception as e:
        logger.error(f"ุฎุทุฃ ูู ุชุดุบูู ุงูุฃุบููุฉ: {e}")
        return False, f"ุญุฏุซ ุฎุทุฃ ุฃุซูุงุก ุชุดุบูู ุงูุฃุบููุฉ: {str(e)}"


async def serve_embedded_song(song: Dict[str, str]) -> Tuple[bool, Any]:
    """
    ุชูุฏูู ููู ุตูุชู ุจูุงุกู ุนูู ูุนูููุงุช ุงูุฃุบููุฉ.
    
    Args:
        song: ูุนูููุงุช ุงูุฃุบููุฉ.
        
    Returns:
        ุฒูุฌ ูู (ูุฌุงุญ ุงูุนูููุฉุ ุงููุชูุฌุฉ) ุญูุซ ุชููู ุงููุชูุฌุฉ ุฅูุง ููู ุตูุชู ุฃู ุฑุณุงูุฉ ุฎุทุฃ.
    """
    song_id = song["id"]
    song_title = song["title"]
    performer = song.get("performer", song.get("source", "ุงูุจูุช ุงูููุณููู"))
    filename = song.get("filename", f"{song_id}.mp3")
    
    try:
        # ุงูุชุญูู ููุง ุฅุฐุง ูุงูุช ุงูุฃุบููุฉ ููุฌูุฏุฉ ูุณุจููุง ูู ุงูุฐุงูุฑุฉ ุงููุคูุชุฉ
        if song_id in song_cache:
            logger.info(f"ุชู ุงุณุชุฑุฌุงุน {song_title} ูู ุงูุฐุงูุฑุฉ ุงููุคูุชุฉ")
            return True, song_cache[song_id]
        
        # ูุณุงุฑ ููู ุงูุฃุบููุฉ
        filepath = os.path.join(MUSIC_DIR, filename)
        
        # ุงูุชุญูู ูู ูุฌูุฏ ุงูููู
        if os.path.exists(filepath):
            logger.info(f"ุชู ุงูุนุซูุฑ ุนูู ููู ุงูุฃุบููุฉ: {filepath}")
            try:
                # ูุฑุงุกุฉ ุงูููู
                with open(filepath, 'rb') as audio_file:
                    file_content = audio_file.read()
                    
                    if len(file_content) == 0:
                        logger.warning(f"ุงูููู {filepath} ูุงุฑุบุ ุณูุชู ุงุณุชุฎุฏุงู ููู ุขุฎุฑ")
                        # ุงุณุชุฎุฏุงู ููู ุขุฎุฑ ูุนุฑูู ุฃูู ุบูุฑ ูุงุฑุบ
                        random_file = os.path.join(MUSIC_DIR, "embedded_song1.mp3")
                        with open(random_file, 'rb') as fallback_file:
                            file_content = fallback_file.read()
                    
                    # ุชุฎุฒูู ุงูุฃุบููุฉ ูู ุงูุฐุงูุฑุฉ ุงููุคูุชุฉ
                    song_cache[song_id] = {
                        'file': file_content,
                        'title': song_title,
                        'performer': performer,
                        'duration': 0  # ูููุฉ ุงูุชุฑุงุถูุฉ ูููุฏุฉ
                    }
                    
                    return True, song_cache[song_id]
            except Exception as file_error:
                logger.error(f"ุฎุทุฃ ูู ูุฑุงุกุฉ ุงูููู {filepath}: {file_error}")
        
        # ุฅุฐุง ูุตููุง ุฅูู ููุงุ ูุฅู ุงูููู ุบูุฑ ููุฌูุฏ ุฃู ูุง ูููู ูุฑุงุกุชู
        # ุณูููู ุจุงุณุชุฎุฏุงู ููู ุขุฎุฑ ุนุดูุงุฆู ูู ุงููููุงุช ุงูููุฌูุฏุฉ
        logger.warning(f"ุงูููู {filename} ุบูุฑ ููุฌูุฏุ ุฌุงุฑู ุงุณุชุฎุฏุงู ููู ุจุฏูู")
        
        # ุฌูุจ ุฌููุน ูููุงุช MP3 ุงููุชุงุญุฉ
        mp3_files = [f for f in os.listdir(MUSIC_DIR) if f.endswith('.mp3')]
        
        if mp3_files:
            # ุงุฎุชูุงุฑ ููู ุนุดูุงุฆู
            random_file = os.path.join(MUSIC_DIR, random.choice(mp3_files))
            logger.info(f"ุงุณุชุฎุฏุงู ุงูููู ุงูุจุฏูู: {random_file}")
            
            # ูุฑุงุกุฉ ุงูููู
            with open(random_file, 'rb') as audio_file:
                file_content = audio_file.read()
                
                # ุชุฎุฒูู ุงูุฃุบููุฉ ูู ุงูุฐุงูุฑุฉ ุงููุคูุชุฉ
                song_cache[song_id] = {
                    'file': file_content,
                    'title': song_title,
                    'performer': performer,
                    'duration': 0  # ูููุฉ ุงูุชุฑุงุถูุฉ ูููุฏุฉ
                }
                
                return True, song_cache[song_id]
        else:
            # ูุง ุชูุฌุฏ ูููุงุช MP3 ุนูู ุงูุฅุทูุงู!
            logger.error("ูู ูุชู ุงูุนุซูุฑ ุนูู ุฃู ูููุงุช ุตูุชูุฉ!")
            return False, "ููุฃุณูุ ูุง ุชูุฌุฏ ูููุงุช ุตูุชูุฉ ูุชุงุญุฉ. ูุฑุฌู ุฅุนุงุฏุฉ ุงููุญุงููุฉ ูุงุญููุง."
    
    except Exception as e:
        logger.error(f"ุฎุทุฃ ูู ุชูุฏูู ุงูุฃุบููุฉ: {e}")
        return False, f"ุบูุฑ ูุงุฏุฑ ุนูู ุชุดุบูู ุงูุฃุบููุฉุ ูุถูุงู ุญุงูู ูุฑุฉ ุฃุฎุฑู ูุงุญููุง."


async def download_using_alternative_method(video_id: str) -> Tuple[bool, Any]:
    """
    ูุญุงููุฉ ุชูุฒูู ุงูููุฏูู ุจุงุณุชุฎุฏุงู ุทุฑููุฉ ุจุฏููุฉ ูู yt-dlp
    
    Args:
        video_id: ูุนุฑู ุงูููุฏูู
        
    Returns:
        ุงูููู ุงูุตูุชู ููุนูููุงุชูุ ุฃู False ูุฑุณุงูุฉ ุงูุฎุทุฃ
    """
    try:
        # ุงูุญุตูู ุนูู ูุนูููุงุช ุงูููุฏูู
        video_info = await get_youtube_info_simple(video_id)
        if not video_info:
            logger.warning(f"ูุดู ูู ุงูุญุตูู ุนูู ูุนูููุงุช ุงูููุฏูู: {video_id}")
            return False, "ูุดู ูู ุงูุญุตูู ุนูู ูุนูููุงุช ุงูููุฏูู"
        
        # ุฅูุดุงุก ูุณุงุฑ ูุคูุช ูุชูุฒูู ุงูููู
        with tempfile.TemporaryDirectory() as temp_dir:
            output_path = os.path.join(temp_dir, f"{video_id}.mp3")
            
            # ุชูุฒูู ุงูููู ูู ูุตุฏุฑ ุจุฏูู
            # ููุง ูููููุง ุงุณุชุฎุฏุงู ูุตุงุฏุฑ ูุฎุชููุฉ ููุชูุฒูู ุฃู ุฎุฏูุงุช ุชุญููู
            
            # ููุซุงู ุจุณูุท ุฌุฏูุง (ุณูุญุชุงุฌ ุฅูู ุชุทููุฑ ูุชุญุณูู):
            url = f"https://www.yt-download.org/api/button/mp3/{video_id}"
            
            user_agent = random.choice(USER_AGENTS)
            headers = {
                'User-Agent': user_agent,
                'Accept-Language': 'en-US,en;q=0.5',
                'Referer': 'https://www.youtube.com/watch',
            }
            
            # ูุฐู ูุฌุฑุฏ ูุญุงููุฉ ูุจุณุทุฉุ ูุณูุญุชุงุฌ ุชูููุฐ ุญูููู ุฅูู:
            # 1. ุงูุชุนุงูู ูุน ุชุชุจุน ุฅุนุงุฏุฉ ุงูุชูุฌูู
            # 2. ุชุญููู HTML ููุญุตูู ุนูู ุฑุงุจุท ุงูุชูุฒูู ุงููุจุงุดุฑ
            # 3. ุงุณุชุฎุฏุงู ุฎุฏูุงุช ุชุญููู ูุชุนุฏุฏุฉ
            
            # ููุงุญุธุฉ: ูุฐู ูุญุงููุฉ ูุฏ ูุง ุชูุฌุญ ุฏุงุฆููุง ูููุถู ุชูููุฐูุง ุจุทุฑููุฉ ุฃูุซุฑ ุชุนููุฏูุง
            
            # ูุญุงูุงุฉ ูุดู ูุฐู ุงูุทุฑููุฉ ูุงุฎุชุจุงุฑ ุงูุณููู ุงูุงุญุชูุงุทู
            return False, "ุงูุทุฑููุฉ ุงูุจุฏููุฉ ุบูุฑ ููุชููุฉ ุงูุชูููุฐ"
            
    except Exception as e:
        logger.error(f"ูุดู ูู ุงูุทุฑููุฉ ุงูุจุฏููุฉ ููุชูุฒูู: {e}")
        return False, str(e)
        

async def download_fallback_song(video_id: str, title: str) -> Tuple[bool, Any]:
    """
    ุฅุฑุฌุงุน ุฃุบููุฉ ุจุฏููุฉ ูุนุฏุฉ ูุณุจููุง.
    
    Args:
        video_id: ูุนุฑู ุงูููุฏูู
        title: ุนููุงู ุงูุฃุบููุฉ
        
    Returns:
        ุงูููู ุงูุตูุชู ููุนูููุงุชู
    """
    try:
        # ุงุฎุชูุงุฑ ุฃุบููุฉ ุนุดูุงุฆูุฉ ูู ุงูุฃุบุงูู ุงููุถููุฉ
        random_song = EMBEDDED_SONGS[random.randint(0, len(EMBEDDED_SONGS)-1)]
        
        # ุฅุนุงุฏุฉ ุฑุณุงูุฉ ุจุฏููุฉ ูููุณุชุฎุฏู ูุงุนูุงูู
        logger.info(f"ุงุณุชุฎุฏุงู ุฃุบููุฉ ุจุฏููุฉ: {random_song['title']} ุจุฏูุงู ูู: {title}")
        
        # ุฅุฑุฌุงุน ุงูุฃุบููุฉ ุงููุถููุฉ
        return await serve_embedded_song(random_song)
    except Exception as e:
        logger.error(f"ุฎุทุฃ ูู ุชูุฏูู ุงูุฃุบููุฉ ุงูุจุฏููุฉ: {e}")
        return False, f"ุบูุฑ ูุงุฏุฑ ุนูู ุชุดุบูู ุฃุบููุฉ ุจุฏููุฉุ ูุถูุงู ุญุงูู ูุงุญููุง."

async def download_music(url: str) -> Tuple[bool, Any]:
    """
    Download music from YouTube URL.
    
    Args:
        url: The YouTube URL.
        
    Returns:
        A tuple of (success, result), where result is either the file path or an error message.
    """
    # Reuse the play_music function as the implementation is the same
    return await play_music(url, 0)  # 0 is a placeholder chat_id

async def get_audio_info(url: str) -> Optional[Dict[str, Any]]:
    """
    Get information about an audio file from a URL.
    
    Args:
        url: The URL to the audio or video ID.
        
    Returns:
        A dictionary with audio information, or None if there was an error.
    """
    # ุงูุชุญูู ููุง ุฅุฐุง ูุงู ุงููุฏุฎู ูุนุฑู ููุฏูู ูููุณ ุฑุงุจุท ูุงูู
    if not url.startswith(('http://', 'https://')):
        # ุฅุฐุง ูุงู ูุนุฑู ููุฏูู ููุทุ ูู ุจุฅูุดุงุก ุฑุงุจุท ููุชููุจ ูุงูู
        if len(url) >= 11:  # ุทูู ูุนุฑู ููุฏูู ุงูููุชููุจ ุงููููุฐุฌู ูู 11 ุญุฑููุง
            url = f"https://www.youtube.com/watch?v={url}"
    
    try:
        ydl_opts = {
            'quiet': True,
            'no_warnings': True,
            'skip_download': True,
            # ุชุฌุงูุฒ ุงููููุฏ
            'nocheckcertificate': True,
            'ignoreerrors': True,
            'no_color': True,
            'geo_bypass': True,
            'geo_bypass_country': 'US',
            # ุชุนููู ุนููู ูุณุชุฎุฏู ูุฎุตุต
            'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'referer': 'https://www.youtube.com/watch'
        }
        
        loop = asyncio.get_event_loop()
        
        try:
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = await loop.run_in_executor(None, lambda: ydl.extract_info(url, download=False))
            
            if not info:
                raise Exception("ูุดู ูู ุงุณุชุฎุฑุงุฌ ูุนูููุงุช ุงูููุฏูู")
                
        except Exception as e:
            logger.warning(f"ูุดูุช ุงููุญุงููุฉ ุงูุฃููู ููุญุตูู ุนูู ูุนูููุงุช ุงูููุฏูู: {e}")
            
            # ุงุณุชุฎุฏุงู ุฎูุงุฑุงุช ุจุฏููุฉ
            alt_opts = ydl_opts.copy()
            alt_opts['extractor_args'] = {'youtube': {'skip': ['dash', 'hls']}}
            alt_opts['source_address'] = '0.0.0.0'  # ููุชุบูุจ ุนูู ูููุฏ IP
            
            try:
                with yt_dlp.YoutubeDL(alt_opts) as ydl:
                    info = await loop.run_in_executor(None, lambda: ydl.extract_info(url, download=False))
                
                if not info:
                    raise Exception("ูุดูุช ุงููุญุงููุฉ ุงูุจุฏููุฉ ูู ุงุณุชุฎุฑุงุฌ ูุนูููุงุช ุงูููุฏูู")
            
            except Exception as alt_e:
                logger.error(f"ูุดูุช ุงููุญุงููุฉ ุงูุจุฏููุฉ ููุญุตูู ุนูู ูุนูููุงุช ุงูููุฏูู: {alt_e}")
                # ุงุณุชุฎุฏุงู ูุนูููุงุช ุงูุชุฑุงุถูุฉ ูุชุฌูุจ ูุดู ุงูุจูุช
                return {
                    'title': os.path.basename(url) if '/' in url else url,
                    'uploader': "ุบูุฑ ูุนุฑูู",
                    'duration': 0,
                    'thumbnail': None,
                    'view_count': 0,
                    'like_count': 0,
                }
        
        return {
            'title': info.get('title', 'Unknown'),
            'uploader': info.get('uploader', 'Unknown'),
            'duration': info.get('duration', 0),
            'thumbnail': info.get('thumbnail', None),
            'view_count': info.get('view_count', 0),
            'like_count': info.get('like_count', 0),
            'video_id': info.get('id', ''),
            'webpage_url': info.get('webpage_url', url),
        }
    except Exception as e:
        logger.error(f"Error getting audio info: {e}")
        return None

def clean_cache():
    """Clean the song cache if it gets too large."""
    global song_cache
    from config import MAX_SONG_CACHE
    
    if len(song_cache) > MAX_SONG_CACHE:
        # Remove oldest entries (first ones in the dictionary)
        items_to_remove = len(song_cache) - MAX_SONG_CACHE
        keys_to_remove = list(song_cache.keys())[:items_to_remove]
        for key in keys_to_remove:
            del song_cache[key]
